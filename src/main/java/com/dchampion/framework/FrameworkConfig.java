package com.dchampion.framework;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class FrameworkConfig {

    @Value("${framework.hash-work-factor:12}")
    private String value;

    @Bean
    public PasswordEncoder encoder() {
        SecureRandom sr = null;
        try {
            // Non-Windows platforms may return a SecureRandom
            // implementation that uses a blocking entropy source to
            // seed itself (e.g. file:/dev/random). Therefore, if this
            // application starts up on a system that was just booted,
            // this call will block until/unless the platform's entropy-
            // gathering device contains enough random bits to seed the
            // SecureRandom instance. This may take a long time on systems
            // lacking input devices; most notably containers, which not
            // only lack input devices, but on which system and application
            // startup are effectively one and the same. If this delay is
            // tolerable, then this is the preferred approach, as it results
            // in the most cryptographically secure SecureRandom instance.
            // If this delay is not tolerable, then you can attempt to over-
            // ride the entropy-gathering device used by the SecureRandom
            // instance to one that does not block, and that is therefore
            // less cryptographically secure. This can be done in one of
            // three ways, in decreasing order of preference:
            // 1) Add "-Djava.security.egd=file:/dev/urandom" to the JVM command
            //    line,
            // 2) Change the property "securerandom.source" to "file:/dev/urandom"
            //    in the JVM's java.security properties file, or
            // 3) Change the property "securerandom.strongAlgorithms" to
            //    "NativePRNG:SUN" (or make it appear first) in the JVM's
            //    java.security properties file.
            // Note that all of these options may be JVM platform-, or even
            // version-, dependent, meaning that in the worst case none of them
            // will override the offending setting. If that is the case, there
            // is a fourth option, which is to replace the call to
            // SecureRandom.getInstanceStrong() to
            // SecureRandom.getInstance("NativePRNG") (only on Non-Windows
            // systems; otherwise continue to use
            // SecureRandom.getInstanceStrong()). Finally, note that the
            // SecureRandom instance obtained here is used specifically for
            // generating "salts" with which to randomize stored passwords.
            // By design, these salts are stored unencrypted in a database.
            // It could be argued that this fact obviates the need for a
            // cryptographically secure random number generator, making the
            // call to SecureRandom.getInstanceStrong() overkill. But until
            // it can be proven that there is no attack, known or otherwise,
            // that can take advantage of salts generated by an RNG less secure
            // than the most secure available, getInstanceStrong() will be the
            // default.
            sr = SecureRandom.getInstanceStrong();
        } catch (NoSuchAlgorithmException nsae) {
            // Ignore.
        }
        // A null sr is acceptable.
        return new BCryptPasswordEncoder(Integer.parseInt(value), sr);
    }
}